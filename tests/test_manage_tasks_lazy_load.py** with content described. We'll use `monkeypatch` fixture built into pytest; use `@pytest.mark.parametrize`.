 In test, patch read_tasks to return tasks built via _build_demo_tasks. Maybe also ensure `tasks_page._load_defined_projects` not reading actual file; but returning [] by default is fine maybe referencing config - but as we call restful contexts in chunk? yes _prepare... uses _load... maybe hitting actual file; but patch to safe path? customizing? For stability we can monkeypatch `_load_defined_projects` to lambda: [] to avoid reading actual file; but default function will attempt to read from config.OUTPUT_PATH, maybe there is actual file maybe not but safe removing? But ensures hooking to real file not heavy; but to avoid reliance we can patch to stub returning [] to avoid reading actual. Also, `unique_sorted_values` uses tasks we supply, ok. So patch: `monkeypatch.setattr(tasks_page, "read_tasks", lambda: [dict(t) for t in _build_demo_tasks(5)])`. also patch `_load_defined_projects`? we can to ensure not reading actual file; maybe expedite by patching to lambda returning []? safe but we need to maintain behavior? It's safe because we only need tasks. We'll patch to stub `lambda: []`. Add these near start of test. Could also patch to ignoring, e.g. `monkeypatch.setattr(tasks_page, "_load_defined_projects", lambda: [])`. yes good. Need to ensure states unaffected after test? yes pyro resets due to monkeypatch fixture. `read_tasks` function used also by initial count? yes. We'll patch once per test? but parameterized, run twice; we can patch before requests to ensure consistent. We'll patch once per test within body. Example: `demo_tasks = _build_demo_tasks(5); monkeypatch...` Each test uses same tasks. We'll also ensure `monkeypatch.setattr(tasks_page, "_load_defined_projects", lambda: [])`. Good. 
